이번엔 코틀린에서 사용이 가능한 '코루틴'에 대해서 한번 코딩해보았다.

이전에도 룸을 사용할 때 메인쓰레드에서 돌리지 말라는 에러때문에 쓰레드를 이용해서 돌린 적이 있었다. 그러면서 코루틴이 좋다느니 뭐라느니 등등 코루틴이 자연스럽게 눈에 띄어서 시도를 하게 되었다.

코루틴은 기본적인 사용처는 쓰레드와 거의 비슷했다. 비동기적으로 뭔가를 하고 싶다.

그런데 조금 코딩을 하면서 사용법이 조금씩 다른 점이 보이긴 했다.

1. UI 작업
  - 쓰레드 : Handler를 통해 메시지를 전달받고 UI를 받아서 작업을 진행.
  - 코루틴 : Dispatcher.Main Yeah
  
  쓰레드를 사용하면서 가장 골머리 아팠던 점이었다. UI작업을 진행하면서 할때마다 핸들러를 부르는 게 참 싫었는데 코루틴에서는 코루틴 내에서 디스패쳐를 메인으로 갈아끠워주기면 하면 만사OK였다.
  
2. 최적화
  정확히 말하면 디스패쳐의 종류를 의미하는 것이다. 디스패쳐는 총 4가지로 구현되어있는데, 어느 상황이 중점이냐에 따라 최적화된 디스패쳐를 사용할 수 있어서 좋았다. 통신이나 파일이면 IO, 연산이면 Default, UI 업데이트면 Main 등등.
  이제는 비동기를 더욱 효율적으로 사용할 수 있게 되는것이다.
  
3. 콜백이 없다.
  코루틴에는 다양한 동기화 방법이 있다. join도 있고 웹 개발자들이라면 익히 알법한 async await도 있고 withContext로 바로 동기화를 해버리는 메소드 또한 존재한다. 손쉽게 동기를 이뤄줄 수 있어서 정말 좋았다. 쓰레드를 사용하면 난리가 났던 콜백들이 말끔하게 사라져서 더 깔끔한 코드가 될 수 있는 것 같아 좋았다.
  
이러한 이유들만 봐도 다중 쓰레드보단 코루틴이 더 코드도 간단하고 효율적으로 짤 수 있었다. 이제부터 코틀린으로 짜는 순간 바로 비동기로 돌릴 때는 코루틴을 이용하자.



지금까지는 사용법에 대해서 차이점과 개발을 함에 있어서 더 어떤 면이 더 편한지에 대해서 생각했지만 이번엔 시시콜콜하지만 이론적인 얘기를 해보자.

아까도 말했지만 코루틴이 하는 것은 쓰레드가 하는거와 차이가 없다. 둘의 공통점은 결국 비동기 작업을 하는 것이니까.

그러면 큰 차이점은 뭐가 있느냐 하고 구글링을 해 본 결과 나보다 더 잘 하는 개발자들의 이야기를 분석한 결과 크게 두 가지였다.

1. 수행 방식
  결론을 먼저 말해보자면 쓰레드는 '병렬성'을 띄고 있고 코루틴은 '동시성'을 띄고 있다.
  개략도로 보면 이해가 빠를 것 같다.
  
          AAAAAAAAAA
  쓰레드
          BBBBBBBBBB
          
  
  
  코루틴   ABABABABABAB
  
  로 이루어진다는 것이다.
  
  나누어 이거했다 저거했다 하는거랑 한꺼번에 같이 실행하는 것이랑의 차이인것이다. 이것은 의외로 코루틴이 크게 단점으로 작용할 수 있다.
  
  만약 3개의 일을 처리하는데 각각 10, 11, 12분이 걸린다고 가정해보자.
  
  그러면 쓰레드는 모두 병렬적으로 처리를 하기 때문에 쓰레드 각각이 일을 처리한다. 이거했다 저거했다가 아니니까 결국에는 10분이 먼저 끝나고 1분있다 11분짜리가 먼저 끝나고, 마지막 1분이 지나면 12분짜리가 끝나서 총 걸리는 시간은 12분이 걸린다.
  하지만 코틀린으로 일을 처리하게 되면 결국 이거했다 저거했다 하는것이기 때문에 10+11+12 = 33분의 시간이 걸리게 된다.
  
  물론 극단적인 상황이라 이렇게 극명하게 차이가 나긴 하지만 이것은 분명히 큰 단점인 것은 맞다.
  
  하지만 이것을 극단적으로 커버해줄 사항 또한 존재한다. 괜히 사람들이 이런 단점이 있어도 코루틴을 권장한다고 헀겠나. 바로 다음 사항에서 이것을 말해준다.
  
2. 비용
  위 게시글을 참고했습니다.  참고 : https://www.charlezz.com/?p=44634
  아래 글은 위의 링크를 간단하게 요약한것이며, 자세하게 보기 위해서는 해당 게시글에 직접 게시되어 있습니다. 

  코틀린 공식 문서에서는 코루틴을 경량 쓰레드라고 말하고 있다. 마치 쓰레드를 경량 프로세스 라고 말하는 것처럼. 코루틴은 쓰레드에서 실행이 되기 때문에 단독으로 실행될 수 없다. 코루틴은 쓰레드 내에서 실행되고 정지가 되면 대기중인 다른 코루틴을 선택할 수 있도록 해방한다. 이렇게 하기 때문에 메모리 사용량이 줄어 더 많은 동시성 작업을 수행할 수 있다. 코틀린의 코루틴은 스택이 없기 때문에 특정 쓰레드에 종속되지 않고 Context Switching도 필요없게 되어 수천개의 쓰레드를 생성하는 것보다 수천개의 코루틴을 생성하는 게 더 빠르다.
  위의 게시글을 보면 똑같은 작업을 해도 엄청난 속도 차이가 난다. 약 4배가량 차이가 났으며 말 그대로 질보단 양으로 승부보는 느낌이다.
  
  
  
다음에는 어떤 것을 생각해볼지 고민중이다. 지금으로서는 Jetpack의 다른 것들을 좀 더 볼 생각이다. Paging이라든지 Navigation이라든지.
